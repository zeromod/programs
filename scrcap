#!/bin/bash

# ==============================================================================
# Live Android Screencap Viewer
#
# Captures all Android displays and shows them in a live-updating HTML viewer.
# Features parallel capture, atomic file updates to prevent flicker, and a
# self-correcting timer to prevent synchronization drift.
#
# Dependencies: adb, bc
# Usage: ./live_screencap.sh [-v] [delay_seconds]
# ==============================================================================

# --- Configuration & Setup ---
set -o errexit -o nounset -o pipefail

DEFAULT_DELAY_SECONDS="1"
VERBOSE=false

# --- Helper Functions ---
log_verbose() {
    [[ "$VERBOSE" = true ]] && echo "VERBOSE: $@"
}

cleanup() {
    echo -e "\n\nShutting down..."
    # Kill all child processes of this script.
    # The check for TEMP_DIR's existence prevents errors if the script fails early.
    if [[ -n "${TEMP_DIR-}" && -d "$TEMP_DIR" ]]; then
        rm -rf "$TEMP_DIR"
    fi
    command -v pkill >/dev/null && pkill -P $$ &>/dev/null
    echo "Cleanup complete."
}

# The main capture loop with a self-correcting timer.
start_continuous_capture() {
    local id=$1
    local final_file="$TEMP_DIR/screencap_display_${id}.png"
    local temp_file="${final_file}.tmp"

    while true; do
        local start_time
        start_time=$(date +%s.%N)

        log_verbose "Capturing Display $id -> ${temp_file}"
        if adb exec-out screencap -p -d "$id" > "$temp_file" 2>/dev/null; then
            mv "$temp_file" "$final_file"
            log_verbose "Updated ${final_file}"
        else
            log_verbose "Capture failed for display $id. Retrying..."
            sleep 1 && continue
        fi

        local end_time
        end_time=$(date +%s.%N)
        local duration
        duration=$(echo "$end_time - $start_time" | bc)
        
        local sleep_duration
        sleep_duration=$(echo "$DELAY_SECONDS - $duration" | bc)

        if (( $(echo "$sleep_duration > 0" | bc -l) )); then
            log_verbose "Capture took ${duration}s. Sleeping for ${sleep_duration}s."
            sleep "$sleep_duration"
        else
            log_verbose "Capture took ${duration}s, longer than delay. Looping immediately."
        fi
    done
}

# --- Main Script Execution ---

# Set up automatic cleanup on exit.
trap cleanup SIGINT SIGTERM EXIT

# --- Argument Parsing ---
while getopts ":v" opt; do
  case ${opt} in
    v) VERBOSE=true ;;
    *) echo "Invalid Option: -$OPTARG" >&2 && exit 1 ;;
  esac
done
shift $((OPTIND -1))
DELAY_SECONDS="${1:-$DEFAULT_DELAY_SECONDS}"

# --- Dependency and Device Check ---
if ! command -v adb &>/dev/null; then echo "ERROR: 'adb' not found." >&2; exit 1; fi
if ! command -v bc &>/dev/null; then echo "ERROR: 'bc' not found." >&2; exit 1; fi

log_verbose "Starting live screencap. Press Ctrl+C to stop."
log_verbose "Target interval: ${DELAY_SECONDS} seconds."

# --- Auto-Detect Display IDs ---
log_verbose "Detecting display IDs..."
# Using a portable `while read` loop for Zsh/macOS compatibility.
DISPLAY_IDS=()
while IFS= read -r id; do
    [[ -n "$id" ]] && DISPLAY_IDS+=("$id")
done < <(adb shell dumpsys SurfaceFlinger --display-id | awk '/^Display / {print $2}' | sort -n | uniq)

if [[ ${#DISPLAY_IDS[@]} -eq 0 ]]; then
    echo "ERROR: No Android displays detected via ADB." >&2
    exit 1
fi
log_verbose "Detected display IDs: ${DISPLAY_IDS[*]}"

# --- Setup Environment ---
TEMP_DIR=$(mktemp -d "${HOME}/.screencap_XXXXXX")
HTML_VIEWER="$TEMP_DIR/image_viewer.html"
log_verbose "Temp directory: $TEMP_DIR"

# --- HTML File Generation ---
JS_DISPLAY_DATA=""
for id in "${DISPLAY_IDS[@]}"; do
    JS_DISPLAY_DATA+=" { id: '${id}', url: 'file://${TEMP_DIR}/screencap_display_${id}.png' },"
done

NUM_DISPLAYS=${#DISPLAY_IDS[@]}
CANVAS_MAX_WIDTH="calc((100vw - $((NUM_DISPLAYS - 1)) * 10px) / $NUM_DISPLAYS)"

log_verbose "Generating '$HTML_VIEWER'..."
cat <<EOF > "$HTML_VIEWER"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Device Preview</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; display: flex; justify-content: center; align-items: center; min-height: 100vh; gap: 10px; }
        canvas { display: block; max-width: ${CANVAS_MAX_WIDTH}; max-height: 100vh; object-fit: contain; image-rendering: pixelated; }
    </style>
</head>
<body>
    <script>
        const displayData = [${JS_DISPLAY_DATA%,}];
        const canvases = {};
        const contexts = {};
        const imageCache = {};

        function loadImageForDisplay(data) {
            const img = imageCache[data.id] = imageCache[data.id] || new Image();
            img.onload = () => {
                const canvas = canvases[data.id];
                const ctx = contexts[data.id];
                if (canvas.width !== img.naturalWidth || canvas.height !== img.naturalHeight) {
                    canvas.width = img.naturalWidth || 300;
                    canvas.height = img.naturalHeight || 200;
                }
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            };
            img.onerror = () => {
                console.warn(\`Failed to load image for display \${data.id}. Will retry.\`);
            };
            img.src = data.url + '?' + Date.now();
        }

        document.addEventListener('DOMContentLoaded', () => {
            const fragment = document.createDocumentFragment();
            displayData.forEach(data => {
                const canvas = document.createElement('canvas');
                canvases[data.id] = canvas;
                contexts[data.id] = canvas.getContext('2d');
                fragment.appendChild(canvas);
            });
            document.body.appendChild(fragment);

            displayData.forEach(loadImageForDisplay);

            setTimeout(() => {
                setInterval(() => displayData.forEach(loadImageForDisplay), ${DELAY_SECONDS} * 1000);
            }, 300);
        });
    </script>
</body>
</html>
EOF

# --- Initial Capture, Browser Launch, and Main Loop ---
echo "Performing initial capture..."
for id in "${DISPLAY_IDS[@]}"; do
    adb exec-out screencap -p -d "$id" > "$TEMP_DIR/screencap_display_${id}.png" 2>/dev/null || true
done
echo "Initial capture complete."

log_verbose "Opening viewer: $HTML_VIEWER"
if command -v xdg-open &>/dev/null; then xdg-open "$HTML_VIEWER" &
elif command -v open &>/dev/null; then open "$HTML_VIEWER" &
else echo "Please open this file in your browser: $HTML_VIEWER" >&2; fi

for id in "${DISPLAY_IDS[@]}"; do
    start_continuous_capture "$id" &
done

echo "All capture processes started. Viewer is active. Press Ctrl+C to stop."
wait
